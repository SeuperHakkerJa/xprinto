import PDFDocument from 'pdfkit';
import fs from 'fs-extra';
import path from 'path';
import { readPath } from '../file-reader';
import { highlightCode, HighlightedFile } from '../syntax/highlighter';
import { renderPage } from './page'; // Removed resetPageCounter import
import { generateTOC } from './toc';
import { log, LogLevel } from '../utils/logger';

export interface PdfOptions {
  title: string;
  theme: string;
  fontSize: number;
  showLineNumbers: boolean;
  paperSize?: [number, number]; // Width, height in points (default A4)
  margins?: { top: number; right: number; bottom: number; left: number };
  headerHeight?: number;
  footerHeight?: number;
}

// Default options - with better default sizes
const defaultOptions: PdfOptions = {
  title: 'Code Documentation',
  theme: 'github',
  fontSize: 11, // Increased from 10
  showLineNumbers: true,
  paperSize: [595.28, 841.89], // A4
  margins: { top: 50, right: 50, bottom: 50, left: 50 },
  headerHeight: 40, // Increased slightly
  footerHeight: 30
};

export async function generatePdfFromPath(
  inputPath: string,
  outputPath: string,
  options: Partial<PdfOptions> = {}
): Promise<void> {
  // Merge options with defaults
  const mergedOptions: PdfOptions = { ...defaultOptions, ...options };
  
  try {
    // Read all files
    log(`Reading files from ${inputPath}...`, LogLevel.INFO);
    const files = await readPath(inputPath);
    
    // Highlight code for all files
    log('Applying syntax highlighting...', LogLevel.INFO);
    const highlightedFiles: HighlightedFile[] = files.map(file => highlightCode(file));
    
    // Create PDF document
    log('Generating PDF...', LogLevel.INFO);
    const doc = new PDFDocument({
      size: mergedOptions.paperSize,
      margins: mergedOptions.margins,
      info: {
        Title: mergedOptions.title,
        Author: 'Generated by xprinto',
        Creator: 'xprinto'
      }
    });
    
    // Create write stream
    const writeStream = fs.createWriteStream(outputPath);
    doc.pipe(writeStream);
    
    // Add cover page
    addCoverPage(doc, inputPath, mergedOptions);
    
    // Add table of contents if there are multiple files
    if (highlightedFiles.length > 1) {
      log('Generating table of contents...', LogLevel.INFO);
      generateTOC(doc, highlightedFiles, mergedOptions);
    }
    
    // Add each file to the PDF
    for (const file of highlightedFiles) {
      log(`Adding file to PDF: ${file.relativePath}`, LogLevel.INFO);
      doc.addPage();
      renderPage(doc, file, mergedOptions);
    }
    
    // Finalize the PDF
    doc.end();
    
    // Wait for the write stream to finish
    await new Promise<void>((resolve, reject) => {
      writeStream.on('finish', () => {
        log(`PDF written to ${outputPath}`, LogLevel.SUCCESS);
        resolve();
      });
      writeStream.on('error', reject);
    });
  } catch (err) {
    throw new Error(`Failed to generate PDF: ${(err as Error).message}`);
  }
}

// Function to add a cover page
function addCoverPage(doc: PDFKit.PDFDocument, inputPath: string, options: PdfOptions): void {
  // Set font for cover page
  doc.font('Helvetica-Bold')
     .fontSize(24)
     .text(options.title, { align: 'center' })
     .moveDown(2);
  
  // Add input path information
  doc.font('Helvetica')
     .fontSize(14)
     .text(`Source: ${path.resolve(inputPath)}`, { align: 'center' })
     .moveDown(1);
  
  // Add generation date
  doc.fontSize(12)
     .text(`Generated on: ${new Date().toLocaleString()}`, { align: 'center' })
     .moveDown(4);
  
  // Add separator line
  const pageWidth = options.paperSize![0] - options.margins!.left - options.margins!.right;
  doc.moveTo(options.margins!.left, doc.y)
     .lineTo(options.margins!.left + pageWidth, doc.y)
     .stroke();
  
  // Add description
  doc.moveDown(2)
     .fontSize(12)
     .text('This document contains a formatted representation of the code with syntax highlighting and line numbers for easy reference. Navigate through the document using the table of contents (if available).', {
       align: 'left',
       width: pageWidth
     });
}