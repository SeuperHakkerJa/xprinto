import hljs from 'highlight.js';
import { FileInfo, HighlightedFile, HighlightedLine, HighlightedToken, SyntaxTheme } from './utils/types';
import { logger } from './utils/logger';
import he from 'he'; // Use 'he' library for robust HTML entity decoding

// --- Language Mapping ---
// Add mappings for extensions highlight.js might not guess correctly
const LANGUAGE_MAP: Record<string, string> = {
    'ts': 'typescript',
    'tsx': 'typescript',
    'js': 'javascript',
    'jsx': 'javascript',
    'py': 'python',
    'rb': 'ruby',
    'java': 'java',
    'cs': 'csharp',
    'go': 'go',
    'php': 'php',
    'html': 'html',
    'css': 'css',
    'scss': 'scss',
    'less': 'less',
    'json': 'json',
    'yaml': 'yaml',
    'yml': 'yaml',
    'md': 'markdown',
    'sh': 'bash',
    'bash': 'bash',
    'zsh': 'bash',
    'sql': 'sql',
    'xml': 'xml',
    'kt': 'kotlin',
    'swift': 'swift',
    'pl': 'perl',
    'rs': 'rust',
    'lua': 'lua',
    'dockerfile': 'dockerfile',
    'h': 'c', // Often C or C++ header
    'hpp': 'cpp',
    'cpp': 'cpp',
    'c': 'c',
    'm': 'objectivec',
    'mm': 'objectivec',
    // Add more as needed
};

// --- Theme Mapping ---
// Maps highlight.js CSS classes to theme token types
function mapHljsClassToThemeToken(className: string): keyof SyntaxTheme['tokenColors'] | null {
    if (className.includes('comment')) return 'comment';
    if (className.includes('keyword')) return 'keyword';
    if (className.includes('string')) return 'string';
    if (className.includes('number')) return 'number';
    if (className.includes('literal')) return 'literal'; // true, false, null
    if (className.includes('built_in')) return 'built_in'; // console, Math
    if (className.includes('function')) return 'function'; // Function definition keyword
    // Check for title but exclude class titles specifically
    if (className.includes('title') && !className.includes('class')) return 'title'; // Function/method names, important vars
    if (className.includes('class') && className.includes('title')) return 'class'; // Class definition name
    if (className.includes('params')) return 'params'; // Function parameters
    if (className.includes('property')) return 'property'; // Object properties
    if (className.includes('operator')) return 'operator';
    if (className.includes('punctuation')) return 'punctuation';
    if (className.includes('tag')) return 'tag'; // HTML/XML tags
    if (className.includes('attr') || className.includes('attribute')) return 'attr'; // HTML/XML attributes
    if (className.includes('variable')) return 'variable';
    if (className.includes('regexp')) return 'regexp';
    // Add more specific mappings if needed based on highlight.js output
    return null;
}

// --- Font Style Mapping ---
function getFontStyle(className: string, theme: SyntaxTheme): HighlightedToken['fontStyle'] {
    const styles = theme.fontStyles || {};
    if (className.includes('comment') && styles.comment === 'italic') return 'italic';
    if (className.includes('keyword') && styles.keyword === 'bold') return 'bold';
    // Add more style mappings based on theme config
    return 'normal'; // Return the literal 'normal'
}


/**
 * Detects the language for highlighting based on file extension.
 * @param extension The file extension (without the dot).
 * @returns The language name recognized by highlight.js or the extension itself.
 */
function detectLanguage(extension: string): string {
    const lowerExt = extension.toLowerCase();
    return LANGUAGE_MAP[lowerExt] || lowerExt; // Fallback to extension if no mapping
}

/**
 * Parses the HTML output of highlight.js to extract tokens with styles.
 * This version aims to be more robust in handling nested spans and plain text.
 * @param highlightedHtml The HTML string generated by hljs.highlight().value
 * @param theme The syntax theme to apply colors from.
 * @returns An array of HighlightedToken objects.
 */
function parseHighlightedHtml(highlightedHtml: string, theme: SyntaxTheme): HighlightedToken[] {
    const tokens: HighlightedToken[] = [];
    // Use a simple stack-based parser approach
    const stack: { tag: string; class?: string }[] = [];
    let currentText = '';
    let currentIndex = 0;

    while (currentIndex < highlightedHtml.length) {
        const tagStart = highlightedHtml.indexOf('<', currentIndex);

        // Text before the next tag (or end of string)
        const textBeforeTag = tagStart === -1
            ? highlightedHtml.substring(currentIndex)
            : highlightedHtml.substring(currentIndex, tagStart);

        if (textBeforeTag) {
            currentText += textBeforeTag;
        }

        if (tagStart === -1) {
            // End of string
            if (currentText) {
                const decodedText = he.decode(currentText); // Decode entities
                const currentStyle = stack[stack.length - 1];
                const themeKey = currentStyle?.class ? mapHljsClassToThemeToken(currentStyle.class) : null;
                tokens.push({
                    text: decodedText,
                    color: themeKey ? theme.tokenColors[themeKey] : theme.defaultColor,
                    fontStyle: currentStyle?.class ? getFontStyle(currentStyle.class, theme) : 'normal', // Use 'normal' literal
                });
            }
            break; // Exit loop
        }

        const tagEnd = highlightedHtml.indexOf('>', tagStart);
        if (tagEnd === -1) {
            // Malformed HTML? Treat rest as text
             logger.warn("Malformed HTML detected in highlighter output.");
             currentText += highlightedHtml.substring(tagStart);
             if (currentText) {
                 const decodedText = he.decode(currentText);
                 const currentStyle = stack[stack.length - 1];
                 const themeKey = currentStyle?.class ? mapHljsClassToThemeToken(currentStyle.class) : null;
                 tokens.push({
                     text: decodedText,
                     color: themeKey ? theme.tokenColors[themeKey] : theme.defaultColor,
                     fontStyle: currentStyle?.class ? getFontStyle(currentStyle.class, theme) : 'normal', // Use 'normal' literal
                 });
             }
             break;
        }

        const tagContent = highlightedHtml.substring(tagStart + 1, tagEnd);
        const isClosingTag = tagContent.startsWith('/');

        // Process accumulated text before handling the tag
        if (currentText) {
             const decodedText = he.decode(currentText); // Decode entities just before pushing
             const currentStyle = stack[stack.length - 1];
             const themeKey = currentStyle?.class ? mapHljsClassToThemeToken(currentStyle.class) : null;
             tokens.push({
                 text: decodedText,
                 color: themeKey ? theme.tokenColors[themeKey] : theme.defaultColor,
                 fontStyle: currentStyle?.class ? getFontStyle(currentStyle.class, theme) : 'normal', // Use 'normal' literal
             });
             currentText = ''; // Reset accumulated text
        }

        if (isClosingTag) {
            // Pop from stack if it's the corresponding closing tag
            const tagName = tagContent.substring(1).trim();
            if (stack.length > 0 && stack[stack.length - 1].tag === tagName) {
                stack.pop();
            } else {
                 logger.warn(`Mismatched closing tag </${tagName}> encountered.`);
            }
        } else {
            // Opening tag
            const parts = tagContent.split(/\s+/);
            const tagName = parts[0];
            let className: string | undefined;
            // Very basic class attribute parsing
            const classAttrMatch = tagContent.match(/class="([^"]*)"/);
            if (classAttrMatch) {
                className = classAttrMatch[1];
            }
            stack.push({ tag: tagName, class: className });
        }

        currentIndex = tagEnd + 1;
    }

     // Filter out empty tokens that might result from decoding/parsing artifacts
    return tokens.filter(token => token.text.length > 0);
}


/**
 * Highlights the code content of a file.
 * @param fileInfo Information about the file.
 * @param theme The syntax theme to use for colors.
 * @returns A HighlightedFile object with tokenized lines.
 */
export function highlightCode(fileInfo: FileInfo, theme: SyntaxTheme): HighlightedFile {
    const language = detectLanguage(fileInfo.extension);
    logger.debug(`Highlighting ${fileInfo.relativePath} as language: ${language}`);

    const highlightedLines: HighlightedLine[] = [];
    const lines = fileInfo.content.split(/\r?\n/); // Split into lines

    try {
        // Process line by line
        lines.forEach((line, index) => {
            let lineTokens: HighlightedToken[];

            if (line.trim() === '') {
                // Handle empty lines
                lineTokens = [{ text: '', fontStyle: 'normal', color: theme.defaultColor }]; // Use 'normal' literal
            } else {
                // Define result type using the imported hljs object's types if needed,
                // but often type inference from the highlight functions is sufficient.
                // Using 'any' temporarily if inference fails or types are complex.
                let result: any; // Use 'any' or rely on inference. Avoid 'hljs.HighlightResult' directly.
                try {
                    // Try highlighting with the detected language
                    if (hljs.getLanguage(language)) {
                        result = hljs.highlight(line, { language: language, ignoreIllegals: true });
                    } else {
                        // Fallback to auto-detection if language is not supported
                        logger.debug(`Language '${language}' not explicitly supported by highlight.js, attempting auto-detect for line ${index + 1} in ${fileInfo.relativePath}`);
                        result = hljs.highlightAuto(line);
                    }
                } catch (e) {
                    logger.warn(`Highlighting failed for line ${index + 1} in ${fileInfo.relativePath}, using plain text. Error: ${(e as Error).message}`);
                    // Fallback: treat the whole line as default text
                    // Ensure the fallback structure matches HighlightResult structure minimally
                    result = { value: he.encode(line), language: 'plaintext', relevance: 0 }; // Encode to mimic hljs output
                }

                // Parse the HTML output into tokens
                // Ensure 'result.value' is a string before passing
                 lineTokens = parseHighlightedHtml(result?.value || he.encode(line), theme);


                 // If parsing results in empty tokens (shouldn't happen often), fallback
                 if (lineTokens.length === 0 && line.length > 0) {
                    logger.debug(`Token parsing resulted in empty array for non-empty line ${index + 1} in ${fileInfo.relativePath}. Using plain text token.`);
                    lineTokens = [{ text: line, color: theme.defaultColor, fontStyle: 'normal' }]; // Use 'normal' literal
                }
            }

            highlightedLines.push({
                lineNumber: index + 1,
                tokens: lineTokens,
            });
        });

    } catch (error) {
        logger.error(`Critical error during highlighting process for ${fileInfo.relativePath}: ${(error as Error).message}`);
        // Fallback: return unhighlighted structure
        const fallbackLines = lines.map((line, index) => ({
            lineNumber: index + 1,
            tokens: [{ text: line, color: theme.defaultColor, fontStyle: 'normal' as const }], // Use 'normal' literal and 'as const' for type safety
        }));
        return {
            ...fileInfo,
            language: 'plaintext', // Mark as plaintext due to error
            highlightedLines: fallbackLines, // This should now match the expected type
        };
    }

    return {
        ...fileInfo,
        language: language, // Store the detected language
        highlightedLines,
    };
}
